<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>lobster builtin function reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<style type="text/css">table.a, tr.a, td.a {font-size: 10pt;border: 1pt solid #DDDDDD; border-Collapse: collapse; max-width:1200px}</style>
</head>
<body><center><table border=0><tr><td>
<p>lobster builtin functions:(file auto generated by compiler, do not modify)</p>

<h3>treesheets</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_root</b>()</tt></td><td class="a">makes the root of the document the current cell. this is the default at the startof any script, so this function is only needed to return there.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_view</b>()</tt></td><td class="a">makes what the user has zoomed into the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.has_selection</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether there is a selection.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_selection</b>()</tt></td><td class="a">makes the current cell the one selected, or the first of a selection.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.has_parent</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether the current cell has a parent (is the root cell).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_parent</b>()</tt></td><td class="a">makes the current cell the parent of the current cell, if any.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.num_children</b>() -> <font color="#666666">int</font></tt></td><td class="a">returns the total number of children of the current cell (rows * columns).returns 0 if this cell doesn't have a sub-grid at all.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.num_columns_rows</b>() -> <font color="#666666">int2</font></tt></td><td class="a">returns the number of columns &amp; rows in the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.selection</b>() -> <font color="#666666">int2</font>, <font color="#666666">int2</font></tt></td><td class="a">returns the (xs,ys) and (x,y) of the current selection, or zeroes if none.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_child</b>(n<font color="#666666">:int</font>)</tt></td><td class="a">makes the current cell the nth child of the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.goto_column_row</b>(col<font color="#666666">:int</font>, row<font color="#666666">:int</font>)</tt></td><td class="a">makes the current cell the child at col / row.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.get_text</b>() -> <font color="#666666">string</font></tt></td><td class="a">gets the text of the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_text</b>(text<font color="#666666">:string</font>)</tt></td><td class="a">sets the text of the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.create_grid</b>(cols<font color="#666666">:int</font>, rows<font color="#666666">:int</font>)</tt></td><td class="a">creates a grid in the current cell if there isn't one yet.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.insert_column</b>(c<font color="#666666">:int</font>)</tt></td><td class="a">insert n columns before column c in an existing grid.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.insert_row</b>(r<font color="#666666">:int</font>)</tt></td><td class="a">insert n rows before row r in an existing grid.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.delete</b>(pos<font color="#666666">:int2</font>, size<font color="#666666">:int2</font>)</tt></td><td class="a">clears the cells denoted by pos/size. also removes columns/rows if they becomecompletely empty, or the entire grid.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_background_color</b>(col<font color="#666666">:float4</font>)</tt></td><td class="a">sets the background color of the current cell</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_text_color</b>(col<font color="#666666">:float4</font>)</tt></td><td class="a">sets the text color of the current cell</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_text_filtered</b>(filtered<font color="#666666">:bool</font>)</tt></td><td class="a">sets the text filtered of the current cell</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.is_text_filtered</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether the text of the current cell is filtered</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_border_color</b>(col<font color="#666666">:float4</font>)</tt></td><td class="a">sets the border color of the current grid</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_relative_size</b>(s<font color="#666666">:int</font>)</tt></td><td class="a">sets the relative size (0 is normal, -1 is smaller etc.) of the current cell</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_style_bits</b>(s<font color="#666666">:int</font>)</tt></td><td class="a">sets one or more styles (bold = 1, italic = 2, fixed = 4, underline = 8, strikethru = 16) on the current cell.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_status_message</b>(msg<font color="#666666">:string</font>)</tt></td><td class="a">sets the status message in TreeSheets.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.get_filename_from_user</b>(is_save<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">gets a filename using a file dialog. empty string if cancelled.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.get_filename</b>() -> <font color="#666666">string</font></tt></td><td class="a">gets the current documents file name.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.load_document</b>(filename<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">loads a document, and makes it the active one. returns false if failed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.set_window_size</b>(width<font color="#666666">:int</font>, height<font color="#666666">:int</font>)</tt></td><td class="a">resizes the window</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ts.last_edit</b>() -> <font color="#666666">int</font></tt></td><td class="a">gets the timestamp of the last edit in milliseconds since the Unix/C epoch</td></tr>
</table>
<h3>builtin</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>print</b>(x<font color="#666666">:string</font>)</tt></td><td class="a">output any value to the console (with linefeed).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string</b>(x<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">convert any value to string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_depth</b>(depth<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: sets max vectors/objects recursion depth (default 10), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_length</b>(len<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: sets max string length (default 100000), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_quoted</b>(quoted<font color="#666666">:bool</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: if the top level value is a string, whether to convert it with escape codes and quotes (default false), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_decimals</b>(decimals<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: number of decimals for any floating point output (default -1, meaning all), returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_print_indent</b>(spaces<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">for printing / string conversion: number of spaces to indent with. default is 0: no indent / no multi-line, returns old value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_line</b>(prefix<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">reads a string from the console if possible (followed by enter). Prefix will be printed before the input</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>append</b>(xs<font color="#666666">:[any]</font>, ys<font color="#666666">:[any]</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">creates a new vector by appending all elements of 2 input vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>append_into</b>(dest<font color="#666666">:[any]</font>, src<font color="#666666">:[any]</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">appends all elements of the second vector into the first</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vector_capacity</b>(xs<font color="#666666">:[any]</font>, len<font color="#666666">:int</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">ensures the vector capacity (number of elements it can contain before re-allocating) is at least "len". Does not actually add (or remove) elements. This function is just for efficiency in the case the amount of "push" operations is known. returns original vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of int (identity function, useful in combination with string/vector version)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(s<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>length</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">length of vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>equal</b>(a<font color="#666666"></font>, b<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">structural equality between any two values (recurses into vectors/objects, unlike == which is only true for vectors/objects if they are the same object)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>push</b>(xs<font color="#666666">:[any]</font>, x<font color="#666666"></font>) -> <font color="#666666">[any]</font></tt></td><td class="a">appends one element to a vector, returns existing vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pop</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">any</font></tt></td><td class="a">removes last element from vector and returns it</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>top</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">any</font></tt></td><td class="a">returns last element from vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>insert</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>, x<font color="#666666"></font>) -> <font color="#666666">[any]</font></tt></td><td class="a">inserts a value into a vector at index i, existing elements shift upward, returns original vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>) -> <font color="#666666">any</font></tt></td><td class="a">remove element at index i, following elements shift down. returns the element removed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove_range</b>(xs<font color="#666666">:[any]</font>, i<font color="#666666">:int</font>, n<font color="#666666">:int</font>)</tt></td><td class="a">remove n elements at index i, following elements shift down.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>remove_obj</b>(xs<font color="#666666">:[any]</font>, obj<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">remove all elements equal to obj (==), returns obj.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[int]</font>, key<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">does a binary search for key in a sorted vector, returns as first return value how many matches were found, and as second the index in the array where the matches start (so you can read them, overwrite them, or remove them), or if none found, where the key could be inserted such that the vector stays sorted. This overload is for int vectors and keys.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[float]</font>, key<font color="#666666">:float</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">float version.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search</b>(xs<font color="#666666">:[string]</font>, key<font color="#666666">:string</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">string version.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search_object</b>(xs<font color="#666666">:[any]</font>, key<font color="#666666"></font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">object version. compares by reference rather than contents.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search_first_field_string</b>(xs<font color="#666666">:[any]</font>, key<font color="#666666">:string</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">object version where key is the first field (must be string, runtime error if it is not)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>binary_search_first_field_object</b>(xs<font color="#666666">:[any]</font>, key<font color="#666666"></font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">object version where key is the first field (must be object, runtime error if it is not)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>copy</b>(x<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">makes a shallow copy of any object/vector/string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>deepcopy</b>(x<font color="#666666"></font>, depth<font color="#666666">:int</font>) -> <font color="#666666">any</font></tt></td><td class="a">makes a deep copy of any object/vector/string. DAGs become trees, and cycles will clone until it reach the given depth. depth == 1 would do the same as copy.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>slice</b>(xs<font color="#666666">:[any]</font>, start<font color="#666666">:int</font>, size<font color="#666666">:int</font>) -> <font color="#666666">[any]</font></tt></td><td class="a">returns a sub-vector of size elements from index start. size can be negative to indicate the rest of the vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>any</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether any elements of the vector are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>any</b>(xs<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether any elements of the numeric struct are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>all</b>(xs<font color="#666666">:[any]</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether all elements of the vector are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>all</b>(xs<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns whether all elements of the numeric struct are true values</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>substring</b>(s<font color="#666666">:string</font>, start<font color="#666666">:int</font>, size<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a substring of size characters from index start. size can be negative to indicate the rest of the string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>find_string</b>(s<font color="#666666">:string</font>, substr<font color="#666666">:string</font>, offset<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">finds the index at which substr first appears, or -1 if none. optionally start at a position other than 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>find_string_reverse</b>(s<font color="#666666">:string</font>, substr<font color="#666666">:string</font>, offset<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">finds the index at which substr first appears when searching from the end, or -1 if none. optionally start at a position other than the end of the string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>replace_string</b>(s<font color="#666666">:string</font>, a<font color="#666666">:string</font>, b<font color="#666666">:string</font>, count<font color="#666666">:int</font> = 0) -> <font color="#666666">string</font></tt></td><td class="a">returns a copy of s where all occurrences of a have been replaced with b. if a is empty, no replacements are made. if count is specified, makes at most that many replacements</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_int</b>(s<font color="#666666">:string</font>, base<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">converts a string to an int given the base (2..36, e.g. 16 for hex, default is 10).returns 0 if no numeric data could be parsed; second return value is true if allcharacters of the string were parsed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_float</b>(s<font color="#666666">:string</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">converts a string to a float. returns 0.0 if no numeric data could be parsed;second return value is true if all characters of the string were parsed.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>tokenize</b>(s<font color="#666666">:string</font>, delimiters<font color="#666666">:string</font>, whitespace<font color="#666666">:string</font>, dividing<font color="#666666">:int</font> = 0) -> <font color="#666666">[string]</font></tt></td><td class="a">splits a string into a vector of strings, by splitting into segments upon each dividing or terminating delimiter. Segments are stripped of leading and trailing whitespace. Example: "; A ; B C;; " becomes [ "", "A", "B C", "" ] with ";" as delimiter and " " as whitespace. If dividing was true, there would be a 5th empty string element.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>unicode_to_string</b>(us<font color="#666666">:[int]</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a vector of ints representing unicode values to a UTF-8 string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>string_to_unicode</b>(s<font color="#666666">:string</font>) -> <font color="#666666">[int]</font>, <font color="#666666">int</font></tt></td><td class="a">converts a UTF-8 string into a vector of unicode values. second return value is false if there was a decoding error, and the vector will only contain the characters up to the error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>number_to_string</b>(number<font color="#666666">:int</font>, base<font color="#666666">:int</font>, minchars<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts the (unsigned version) of the input integer number to a string given the base (2..36, e.g. 16 for hex) and outputting a minimum of characters (padding with 0).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lowercase</b>(s<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a UTF-8 string from any case to lower case, affecting only A-Z</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>uppercase</b>(s<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">converts a UTF-8 string from any case to upper case, affecting only a-z</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>escape_string</b>(s<font color="#666666">:string</font>, set<font color="#666666">:string</font>, prefix<font color="#666666">:string</font>, postfix<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">prefixes &amp; postfixes any occurrences or characters in set in string s</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>concat_string</b>(v<font color="#666666">:[string]</font>, sep<font color="#666666">:string</font>) -> <font color="#666666">string</font></tt></td><td class="a">concatenates all elements of the string vector, separated with sep.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>repeat_string</b>(s<font color="#666666">:string</font>, n<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a string consisting of n copies of the input string.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:int</font>, b<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">a raised to the power of b, for integers, using exponentiation by squaring</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:float</font>, b<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">a raised to the power of b</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pow</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">vector elements raised to the power of b</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>log</b>(a<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">natural logaritm of a</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>log2</b>(a<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">base 2 logaritm of a</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sqrt</b>(f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">square root</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ceiling</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">the nearest int &gt;= f</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ceiling</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">the nearest ints &gt;= each component of v</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>floor</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">the nearest int &lt;= f</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>floor</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">the nearest ints &lt;= each component of v</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>int</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">converts a float to an int by dropping the fraction</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>int</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">converts a vector of floats to ints by dropping the fraction</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>round</b>(f<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">converts a float to the closest int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>round</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">converts a vector of floats to the closest ints</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>fraction</b>(f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">returns the fractional part of a float: short for f - floor(f)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>fraction</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">returns the fractional part of a vector of floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>float</b>(i<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an int to float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>float</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">converts a vector of ints to floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sin</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the y coordinate of the normalized vector indicated by angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sin</b>(angle<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">the y coordinates of the normalized vector indicated by the angles (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cos</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the x coordinate of the normalized vector indicated by angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cos</b>(angle<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">the x coordinates of the normalized vector indicated by the angles (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>tan</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the tangent of an angle (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>tan</b>(angle<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">the tangents of the angles (in degrees)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sincos</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float2</font></tt></td><td class="a">the normalized vector indicated by angle (in degrees), same as xy { cos(angle), sin(angle) }</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>asin</b>(y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the y coordinate projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>acos</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the x coordinate projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>atan</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) indicated by the y coordinate of the tangent projected to the unit circle</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>radians</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in degrees to radians</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>degrees</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in radians to degrees</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>atan2</b>(vec<font color="#666666">:float2</font>) -> <font color="#666666">float</font></tt></td><td class="a">the angle (in degrees) corresponding to a normalized 2D vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>radians</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in degrees to radians</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>degrees</b>(angle<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">converts an angle in radians to degrees</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>normalize</b>(vec<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">returns a vector of unit length</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>dot</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the length of vector a when projected onto b (or vice versa)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the geometric length of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude_squared</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the geometric length of a vector squared</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>magnitude_squared</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the geometric length of a vector squared</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>manhattan</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the manhattan distance of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cross</b>(a<font color="#666666">:float3</font>, b<font color="#666666">:float3</font>) -> <font color="#666666">float3</font></tt></td><td class="a">a perpendicular vector to the 2D plane defined by a and b (swap a and b for its inverse)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>volume</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">the volume of the area spanned by the vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>volume</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">the volume of the area spanned by the vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd</b>(max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">a random value [0..max).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd</b>(max<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">a random vector within the range of an input vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_float</b>() -> <font color="#666666">float</font></tt></td><td class="a">a random float [0..1)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_gaussian</b>() -> <font color="#666666">float</font></tt></td><td class="a">a random float in a gaussian distribution with mean 0 and stddev 1</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rnd_seed</b>(seed<font color="#666666">:int</font>)</tt></td><td class="a">explicitly set a random seed for reproducable randomness</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rndm</b>(max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">deprecated: old mersenne twister version of the above for backwards compat.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rndm_seed</b>(seed<font color="#666666">:int</font>)</tt></td><td class="a">deprecated: old mersenne twister version of the above for backwards compat.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>div</b>(a<font color="#666666">:int</font>, b<font color="#666666">:int</font>) -> <font color="#666666">float</font></tt></td><td class="a">forces two ints to be divided as floats</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:int</font>, min<font color="#666666">:int</font>, max<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">forces an integer to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:float</font>, min<font color="#666666">:float</font>, max<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">forces a float to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:vec_i</font>, min<font color="#666666">:vec_i</font>, max<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">forces an integer vector to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>clamp</b>(x<font color="#666666">:vec_f</font>, min<font color="#666666">:vec_f</font>, max<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">forces a float vector to be in the range between min and max (inclusive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int</font>, range<font color="#666666">:int</font>, bias<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">checks if an integer is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float</font>, range<font color="#666666">:float</font>, bias<font color="#666666">:float</font> = 0.000000) -> <font color="#666666">int</font></tt></td><td class="a">checks if a float is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int2</font>, range<font color="#666666">:int2</font>, bias<font color="#666666">:int2</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d integer vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:int3</font>, range<font color="#666666">:int3</font>, bias<font color="#666666">:int3</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 3d integer vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float2</font>, range<font color="#666666">:float2</font>, bias<font color="#666666">:float2</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d float vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>in_range</b>(x<font color="#666666">:float3</font>, range<font color="#666666">:float3</font>, bias<font color="#666666">:float3</font> = nil) -> <font color="#666666">int</font></tt></td><td class="a">checks if a 2d float vector is &gt;= bias and &lt; bias + range. Bias defaults to 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">absolute value of an integer</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">absolute value of a float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">absolute value of an int vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>abs</b>(x<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">absolute value of a float vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">sign (-1, 0, 1) of an integer</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">sign (-1, 0, 1) of a float</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">signs of an int vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>sign</b>(x<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">signs of a float vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:int</font>, y<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest of 2 integers.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest of 2 floats.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:vec_i</font>, y<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">smallest components of 2 int vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(x<font color="#666666">:vec_f</font>, y<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">smallest components of 2 float vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest component of a int vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest component of a float vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:[int]</font>) -> <font color="#666666">int</font></tt></td><td class="a">smallest component of a int vector, or INT_MAX if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>min</b>(v<font color="#666666">:[float]</font>) -> <font color="#666666">float</font></tt></td><td class="a">smallest component of a float vector, or FLT_MAX if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:int</font>, y<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest of 2 integers.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest of 2 floats.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:vec_i</font>, y<font color="#666666">:vec_i</font>) -> <font color="#666666">vec_i</font></tt></td><td class="a">largest components of 2 int vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(x<font color="#666666">:vec_f</font>, y<font color="#666666">:vec_f</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">largest components of 2 float vectors</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest component of a int vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest component of a float vector.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:[int]</font>) -> <font color="#666666">int</font></tt></td><td class="a">largest component of a int vector, or INT_MIN if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>max</b>(v<font color="#666666">:[float]</font>) -> <font color="#666666">float</font></tt></td><td class="a">largest component of a float vector, or FLT_MIN if length 0.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lerp</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>, f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">linearly interpolates between x and y with factor f [0..1]</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lerp</b>(a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>, f<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">linearly interpolates between a and b vectors with factor f [0..1]</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>spherical_lerp</b>(a<font color="#666666">:float4</font>, b<font color="#666666">:float4</font>, f<font color="#666666">:float</font>) -> <font color="#666666">float4</font></tt></td><td class="a">spherically interpolates between a and b quaternions with factor f [0..1]</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothmin</b>(x<font color="#666666">:float</font>, y<font color="#666666">:float</font>, k<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">k is the influence range</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothstep</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smoothstep</b>(a<font color="#666666">:float</font>, b<font color="#666666">:float</font>, f<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">hermite interpolation between a and b by f [0..1], https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>smootherstep</b>(x<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>cardinal_spline</b>(z<font color="#666666">:vec_f</font>, a<font color="#666666">:vec_f</font>, b<font color="#666666">:vec_f</font>, c<font color="#666666">:vec_f</font>, f<font color="#666666">:float</font>, tension<font color="#666666">:float</font>) -> <font color="#666666">vec_f</font></tt></td><td class="a">computes the position between a and b with factor f [0..1], using z (before a) and c (after b) to form a cardinal spline (tension at 0.5 is a good default)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>line_intersect</b>(line1a<font color="#666666">:float2</font>, line1b<font color="#666666">:float2</font>, line2a<font color="#666666">:float2</font>, line2b<font color="#666666">:float2</font>) -> <font color="#666666">int</font>, <font color="#666666">float2</font></tt></td><td class="a">computes if there is an intersection point between 2 line segments, with the point as second return value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>circles_within_range</b>(dist<font color="#666666">:float</font>, positions<font color="#666666">:[float2]</font>, radiuses<font color="#666666">:[float]</font>, positions2<font color="#666666">:[float2]</font>, radiuses2<font color="#666666">:[float]</font>, gridsize<font color="#666666">:int2</font>) -> <font color="#666666">[[int]]</font></tt></td><td class="a">Given a vector of 2D positions (and same size vectors of radiuses), returns a vector of vectors of indices (to the second set of positions and radiuses) of the circles that are within dist of eachothers radius. If the second set are [], the first set is used for both (and the self element is excluded). gridsize optionally specifies the size of the grid to use for accellerated lookup of nearby points. This is essential for the algorithm to be fast, too big or too small can cause slowdown. Omit it, and a heuristic will be chosen for you, which is currently sqrt(num_circles) * 2 along each dimension, e.g. 100 elements would use a 20x20 grid. Efficiency wise this algorithm is fastest if there is not too much variance in the radiuses of the second set and/or the second set has smaller radiuses than the first.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>wave_function_collapse</b>(tilemap<font color="#666666">:[string]</font>, size<font color="#666666">:int2</font>) -> <font color="#666666">[string]</font>, <font color="#666666">int</font></tt></td><td class="a">returns a tilemap of given size modelled after the possible shapes in the input tilemap. Tilemap should consist of chars in the 0..127 range. Second return value the number of failed neighbor matches, this should ideally be 0, but can be non-0 for larger maps. Simply call this function repeatedly until it is 0</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes an int value into a positive int; may be the identity function</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes any ref value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:function</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a function value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(x<font color="#666666">:float</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a float value into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(v<font color="#666666">:vec_i</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a int vector into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>hash</b>(v<font color="#666666">:vec_f</font>) -> <font color="#666666">int</font></tt></td><td class="a">hashes a float vector into a positive int</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>call_function_value</b>(x<font color="#666666">:function</font>)</tt></td><td class="a">calls a void / no args function value.. you shouldn't need to use this, it is a demonstration of how native code can call back into Lobster</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_id</b>(ref<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">int uniquely representing the type of the given reference (object/vector/string/resource). this is the same as typeof, except dynamic (accounts for subtypes of the static type). useful to compare the types of objects quickly. specializations of a generic type will result in different ids.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_string</b>(ref<font color="#666666"></font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of the given reference (object/vector/string/resource)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_element_string</b>(v<font color="#666666">:[any]</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of the elements of a vector</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_count</b>(obj<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">number of fields in an object, or 0 for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_string</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the type of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_name</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">name of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>type_field_value</b>(obj<font color="#666666"></font>, idx<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">string representing the value of a field in an object, or empty for other reference types</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>program_name</b>() -> <font color="#666666">string</font></tt></td><td class="a">returns the name of the main program (e.g. "foo.lobster"), "" if running from lpak.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vm_compiled_mode</b>() -> <font color="#666666">int</font></tt></td><td class="a">returns if the VM is running in compiled mode (Lobster -&gt; C++), or false for JIT.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>seconds_elapsed</b>() -> <font color="#666666">float</font></tt></td><td class="a">seconds since program start as a float, unlike gl.time() it is calculated every time it is called</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time</b>(utc<font color="#666666">:bool</font> = false) -> <font color="#666666">[int]</font></tt></td><td class="a">a vector of integers representing date &amp; time information (index with date_time.lobster). By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time_string</b>(utc<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">a string representing date &amp; time information in the format: 'Www Mmm dd hh:mm:ss yyyy'. By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time_string_format</b>(format<font color="#666666">:string</font>, utc<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">a string representing date &amp; time information using a formatting string according to https://en.cppreference.com/w/cpp/chrono/c/strftime, for example "%Y_%m_%d_%H_%M_%S". By default returns local time, pass true for UTC instead.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>date_time_build_info</b>() -> <font color="#666666">string</font></tt></td><td class="a">a string representing information from when this program was compiled.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>assert</b>(condition<font color="#666666"></font>) -> <font color="#666666">any</font></tt></td><td class="a">halts the program with an assertion failure if passed false. returns its input. runtime errors like this will contain a stack trace if --runtime-stack-trace is on.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_stack_trace</b>() -> <font color="#666666">string</font></tt></td><td class="a">gets a stack trace of the current location of the program (needs --runtime-stack-trace) without actually stopping the program.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>get_memory_usage</b>(n<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">gets a text showing the top n object types that are using the most memory.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>pass</b>()</tt></td><td class="a">does nothing. useful for empty bodies of control structures.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>trace_bytecode</b>(mode<font color="#666666">:int</font>)</tt></td><td class="a">tracing shows each bytecode instruction as it is being executed, not very useful unless you are trying to isolate a compiler bug. Mode is off(0), on(1) or tail only (2)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>reference_count</b>(val<font color="#666666"></font>) -> <font color="#666666">int</font></tt></td><td class="a">get the reference count of any value. for compiler debugging, mostly</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_console</b>(on<font color="#666666">:bool</font>)</tt></td><td class="a">lets you turn on/off the console window (on Windows)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_output_level</b>(level<font color="#666666">:int</font>)</tt></td><td class="a">0 = debug, 1 = verbose, 2 = warn (default), 3 = error, 4 = program</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>set_exit_code</b>(code<font color="#666666">:int</font>)</tt></td><td class="a">this will be returned when run as a console application</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>command_line_arguments</b>() -> <font color="#666666">[string]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_information</b>() -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">returns the number of hardware threads, and the number of cores</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>is_worker_thread</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether the current thread is a worker thread</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>start_worker_threads</b>(numthreads<font color="#666666">:int</font>)</tt></td><td class="a">launch worker threads</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>stop_worker_threads</b>()</tt></td><td class="a">only needs to be called if you want to stop the worker threads before the end of the program, or if you want to call start_worker_threads again. workers_alive will become false inside the workers, which should then exit.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>workers_alive</b>() -> <font color="#666666">int</font></tt></td><td class="a">whether workers should continue doing work. returns false after stop_worker_threads() has been called.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_write</b>(struct<font color="#666666"></font>)</tt></td><td class="a">put this struct in the thread queue</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_read</b>(type<font color="#666666">:typeid(any)</font>) -> <font color="#666666">any?</font></tt></td><td class="a">get a struct from the thread queue. pass the typeof struct. blocks if no suchstructs available. returns struct, or nil if stop_worker_threads() was called</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>thread_check</b>(type<font color="#666666">:typeid(any)</font>) -> <font color="#666666">any?</font></tt></td><td class="a">tests if a struct is available on the thread queue. pass the typeof struct. returns struct, or nil if none available, or if stop_worker_threads() was called</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>crash_test_cpp_nullptr_exception</b>()</tt></td><td class="a">only for testing crash dump functionality, don't use! :)</td></tr>
</table>
<h3>compiler</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>compile_run_code</b>(code<font color="#666666">:string</font>, args<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">compiles and runs lobster source, sandboxed from the current program (in its own VM). the argument is a string of code. returns the return value of the program as a string, with an error string as second return value, or nil if none. using parse_data(), two program can communicate more complex data structures even if they don't have the same version of struct definitions.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>compile_run_file</b>(filename<font color="#666666">:string</font>, args<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">same as compile_run_code(), only now you pass a filename.</td></tr>
</table>
<h3>file</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>scan_folder</b>(folder<font color="#666666">:string</font>, rel<font color="#666666">:bool</font> = false) -> <font color="#666666">[string]?</font>, <font color="#666666">[int]?</font></tt></td><td class="a">returns two vectors representing all elements in a folder, the first vector containing all names, the second vector containing sizes in bytes (or -1 if a directory). set rel use a relative path, default is absolute. Returns nil if folder couldn't be scanned.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_file</b>(file<font color="#666666">:string</font>, textmode<font color="#666666">:int</font> = 0) -> <font color="#666666">string?</font></tt></td><td class="a">returns the contents of a file as a string, or nil if the file can't be found. you may use either \ or / as path separators</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_file</b>(file<font color="#666666">:string</font>, contents<font color="#666666">:string</font>, textmode<font color="#666666">:int</font> = 0, absolute_path<font color="#666666">:int</font> = 0) -> <font color="#666666">int</font></tt></td><td class="a">creates a file with the contents of a string, returns false if writing wasn't possible</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>rename_file</b>(old_file<font color="#666666">:string</font>, new_file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">renames a file, returns false if it wasn't possible</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>delete_file</b>(file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">deletes a file, returns false if it wasn't possible. Will search in all import dirs.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>exists_file</b>(file<font color="#666666">:string</font>) -> <font color="#666666">int</font></tt></td><td class="a">checks wether a file exists.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>launch_subprocess</b>(commandline<font color="#666666">:[string]</font>, stdin<font color="#666666">:string</font> = nil) -> <font color="#666666">int</font>, <font color="#666666">string</font></tt></td><td class="a">launches a sub process, with optionally a stdin for the process, and returns its return code (or -1 if it couldn't launch at all), and any output</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>vector_to_buffer</b>(vec<font color="#666666">:[any]</font>, width<font color="#666666">:int</font> = 4) -> <font color="#666666">string</font></tt></td><td class="a">converts a vector of ints/floats (or structs of them) to a buffer, where each scalar is written with "width" bytes (1/2/4/8, default 4). Returns nil if the type couldn't be converted. Uses native endianness.</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>ensure_size</b>(string<font color="#666666">:string</font>, size<font color="#666666">:int</font>, char<font color="#666666">:int</font>, extra<font color="#666666">:int</font> = 0) -> <font color="#666666">string</font></tt></td><td class="a">ensures a string is at least size characters. if it is, just returns the existing string, otherwise returns a new string of that size (with optionally extra bytes added), with any new characters set to char. You can specify a negative size to mean relative to the end, i.e. new characters will be added at the start. </td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">writes a value as little endian to a string at location i. Uses ensure_size to make the string twice as long (with extra 0 bytes) if no space. Returns new string if resized, and the index of the location right after where the value was written. The _back version writes relative to the end (and writes before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_int8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_float32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, val<font color="#666666">:float</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">(see write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_substring</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, substr<font color="#666666">:string</font>, nullterm<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a">writes a substring into another string at i (see also write_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>write_substring_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>, substr<font color="#666666">:string</font>, nullterm<font color="#666666">:int</font>) -> <font color="#666666">string</font>, <font color="#666666">int</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>compare_substring</b>(string_a<font color="#666666">:string</font>, i_a<font color="#666666">:int</font>, string_b<font color="#666666">:string</font>, i_b<font color="#666666">:int</font>, len<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if the two substrings are equal (0), or a &lt; b (-1) or a &gt; b (1).</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint16_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint8_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float64_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float32_le</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_int8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint16_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_uint8_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">int</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float64_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>read_float32_le_back</b>(string<font color="#666666">:string</font>, i<font color="#666666">:int</font>) -> <font color="#666666">float</font>, <font color="#666666">int</font></tt></td><td class="a">(see read_int64_le)</td></tr>
</table>
<h3>flatbuffers</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_int64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_int32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_int16</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_int8</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_uint64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_uint32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_uint16</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_uint8</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_float64</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_float32</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>, def<font color="#666666">:float</font>) -> <font color="#666666">float</font></tt></td><td class="a">(see flatbuffers.field_int64)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_string</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">reads a flatbuffer string field, returns "" if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_vector_len</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">reads a flatbuffer vector field length, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_vector</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer vector field element start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_table</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer table field start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_struct</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer struct field start, or 0 if not present</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.field_present</b>(string<font color="#666666">:string</font>, tablei<font color="#666666">:int</font>, vo<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns if a flatbuffer field is present (unequal to default)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.indirect</b>(string<font color="#666666">:string</font>, index<font color="#666666">:int</font>) -> <font color="#666666">int</font></tt></td><td class="a">returns a flatbuffer offset at index relative to itself</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.string</b>(string<font color="#666666">:string</font>, index<font color="#666666">:int</font>) -> <font color="#666666">string</font></tt></td><td class="a">returns a flatbuffer string whose offset is at given index</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.binary_to_json</b>(schemas<font color="#666666">:string</font>, binary<font color="#666666">:string</font>, includedirs<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">returns a JSON string generated from the given binary and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flatbuffers.json_to_binary</b>(schema<font color="#666666">:string</font>, json<font color="#666666">:string</font>, includedirs<font color="#666666">:[string]</font>) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">returns a binary flatbuffer generated from the given json and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error</td></tr>
</table>
<h3>parsedata</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>parse_data</b>(typeid<font color="#666666">:typeid(any)</font>, stringdata<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">parses a string containing a data structure in lobster syntax (what you get if you convert an arbitrary data structure to a string) back into a data structure. supports int/float/string/vector and classes. classes will be forced to be compatible with their  current definitions, i.e. too many elements will be truncated, missing elements will be set to 0/nil if possible. useful for simple file formats. returns the value and an error string as second return value (or nil if no error)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_value_to_binary</b>(val<font color="#666666"></font>, max_nesting<font color="#666666">:int</font> = 0, cycle_detection<font color="#666666">:bool</font> = false) -> <font color="#666666">string</font></tt></td><td class="a">turns any reference value into a flexbuffer. max_nesting defaults to 100. cycle_detection is by default off (expensive)</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_binary_to_value</b>(typeid<font color="#666666">:typeid(any)</font>, flex<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a flexbuffer into a value</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_binary_to_json</b>(flex<font color="#666666">:string</font>, field_quotes<font color="#666666">:bool</font>, indent_string<font color="#666666">:string</font>) -> <font color="#666666">string?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a flexbuffer into a JSON string. If indent_string is empty, will be a single line string</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>flexbuffers_json_to_binary</b>(json<font color="#666666">:string</font>, filename_for_errors<font color="#666666">:string</font> = nil) -> <font color="#666666">string</font>, <font color="#666666">string?</font></tt></td><td class="a">turns a JSON string into a flexbuffer, second value is error, if any</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lobster_value_to_binary</b>(val<font color="#666666"></font>) -> <font color="#666666">string</font></tt></td><td class="a">turns any reference value into a binary using a fast &amp; compact Lobster native serialization format. this is intended for threads/networking, not for storage (since it is not readable by other languages). data structures participating must have been marked by attribute serializable. does not provide protection against cycles, use flexbuffers if that is a concern. </td></tr>
<tr class="a" valign=top><td class="a"><tt><b>lobster_binary_to_value</b>(typeid<font color="#666666">:typeid(any)</font>, bin<font color="#666666">:string</font>) -> <font color="#666666">any?</font>, <font color="#666666">string?</font></tt></td><td class="a">turns binary created by lobster_value_to_binary back into a value</td></tr>
</table>
<h3>matrix</h3>
<table class="a" border=1 cellspacing=0 cellpadding=4>
<tr class="a" valign=top><td class="a"><tt><b>matrix.multiply</b>(a<font color="#666666">:[float]</font>, b<font color="#666666">:[float]</font>) -> <font color="#666666">[float]</font></tt></td><td class="a">input matrices must be 4x4 elements</td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix.rotate_x</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix.rotate_y</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix.rotate_z</b>(angle<font color="#666666">:float2</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
<tr class="a" valign=top><td class="a"><tt><b>matrix.translation</b>(trans<font color="#666666">:float3</font>) -> <font color="#666666">[float]</font></tt></td><td class="a"></td></tr>
</table>
</td></tr></table></center></body>
</html>
